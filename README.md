# CS205-Project-5-A-Class-for-Matrices
CS205 2022-Fall Project 5 - A Class for Matrices

## Part 1 - List of Satisfied Requirements

We aim to provide a compact class for matrices that is both **simple**, **straightforward to use**, and **supports arbitrary data types (that can be stored)**.

* N-dimensions, where `N` is a parameter that can vary from `0` to many, without specialized code for every dimension.
  * By supporting N-dimension matrix, matrices with multiple channels are automatically supported.
* Arbitrary types to store.
* Basic mathematical operations support, including per-element `+`, `-`,`*`,`/`,`%` for each element (if the type `T` supports) supported by built-in ``apply()`` function, and Matrix operations, including `+` and `*`.
* Subscripting support with both **Fortran-style** (`m(1,2,3)`), and **C-style** (`m[1][2][3]`).
* Subscripting in a **fast** and **range-checked** way.
* Move assignment and move constructor to ensure efficient passing of ``Matrix`` results and to eliminate expensive temporaries. (Use of `std::vector` and `std::array`, etc., with default constructors generated by the compiler.)
* **Region of Interest, or ROI**, supported by `Matrix_ref`s and `Matrix_slice`.
* Absence of resource leaks in the form of basic guarantee. (Using `std::vector` and other methods)
* Support for parallel executions of specific operations, such as per-element `apply` and matrix multiplication.
* Support constructor with an `initializer_list` argument that ease the initialization process.



## Part 2 - Source Code & Some Tests

#### Some code for the implementation of Matrix.

This part is used to extract the dimensions from a `std::initializer_list` and load the elements into the `Matrix`.

```c++
namespace Matrix_impl
    {
        /**
         * @brief For initializing a matrix using list initializer
         *
         * @tparam T
         * @tparam N
         */
        template <typename T, size_t N>
        struct Matrix_init
        {
            using type = std::initializer_list<typename Matrix_init<T, N - 1>::type>;
        };
        
        template <typename T>
        struct Matrix_init<T, 1>
        {
            using type = std::initializer_list<T>;
        };

        template <typename T>
        struct Matrix_init<T, 0>; // Undefined on purpose

        /**
         * @brief Check if the initializer_list is well formed.
         *
         * @tparam List
         * @param list
         * @return true
         * @return false
         */
        template <typename List>
        bool check_non_jagged(const List &list)
        {
            auto i = list.begin();
            for (auto j = i + 1; j != list.end(); ++j)
                if (i->size() != j->size())
                    return false;
            return true;
        }

        template <size_t N, typename l, typename List>
        Enable_if<(N == 1), void> add_extents(l &first, const List &list)
        {
            *first++ = list.size();
        }

        /**
         * @brief Recursively add extents to the array, the outmost extent first.
         *
         * @tparam N
         * @tparam l
         * @tparam List
         */
        template <size_t N, typename l, typename List>
        Enable_if<(N > 1), void> add_extents(l &first, const List &list)
        {
            assert(check_non_jagged(list));
            *first = list.size();
            add_extents<N - 1>(++first, *list.begin());
        }

        /**
         * @brief Return an `array` of extents from an `initializer_list`
         *
         * @tparam N
         * @tparam List
         * @param list
         * @return std::array<size_t, N>
         */
        template <size_t N, typename List>
        std::array<size_t, N> derive_extents(const List &list)
        {
            std::array<size_t, N> a;
            auto f = a.begin();
            add_extents<N>(f, list);
            return a;
        }
        
        /**
         * @brief Insert a sequence into the vector when dimension is 1.
         *
         * @tparam T
         * @tparam Vec
         * @param first
         * @param last
         * @param vec
         */
        template <typename T, typename Vec>
        void add_list(const T *first, const T *last, Vec &vec)
        {
            vec.insert(vec.end(), first, last);
        }

        template <typename T, typename Vec>
        void add_list(const std::initializer_list<T> *first, const std::initializer_list<T> *last, Vec &vec)
        {
            for (; first != last; ++first)
                add_list(first->begin(), first->end(), vec);
        }

        
        template <typename T, typename Vec>
        void insert_flat(std::initializer_list<T> list, Vec &vec)
        {
            add_list(list.begin(), list.end(), vec);
        }
    
    	// ...
    };
```

Usage:

```c++
Matrix<double, 2> mat = {
        {2, 3, 3, 3},
        {6, 7, 8, 9},
        {2, 1, 5, 7}};
// or similarly
Matrix<double, 3> mat2 = {
    {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},
    {{10, 11, 12}, {13, 14, 15}, {16, 17, 18}},
    {{19, 20, 21}, {22, 23, 24}, {25, 26, 27}}};
```

If you get the wrong dimension in the list initializer, it is warned:

```c++
Matrix<double, 3> mat2 = {
    {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},
    {{10, 11, 12}, {13, 14}, {16, 17, 18}},
    {{19, 20, 21}, {22, 23, 24}, {25, 26, 27}}};
```

Output:

```shell
Assertion `(elems.size() == Matrix_base<T, N>::desc.size)' failed.
Aborted
```



#### Utilizing move constructors and assignments for intermediate calculation results

```c++
// Ok, compilers are supposed to handle this
Matrix(Matrix &&) = default;
Matrix &operator=(Matrix &&) = default;
```

* It is not hard copy right now, instead handled with care (possibly by `std::move`)
* In the case, that the only member in a `Matrix` is a `std::vector` and another class that uses default constructor and assignment operators, compiler should do better (at least for those default operations, to my understanding).
* For access and referencing the same matrix, we use `Matrix_slice` and `Matrix_ref`, which is a referential `Matrix` that allows both `read` and `write` operations. Additionally, they don't use hard copy, and the result is reflected on the original `Matrix`.
* Reference: *The C++ Programming Language* by Bjarne Stroustrup.



#### Region of Interest

We implement the **Region of Interest** function through `Matrix_slice` and `Matrix_ref`. Through these two classes, the user is allowed to efficiently access elements through both *C-style* and *Fortran-style* subscripting.

```C++
```







